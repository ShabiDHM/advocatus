# FILE: backend/app/api/endpoints/drafting_v2.py
# PHOENIX PROTOCOL - DRAFTING ENDPOINT V2.3 (PYLANCE FIX)
# 1. FIX: Handled Optional[str] for draft_type by providing fallback (TS-35).
# 2. FIX: Re-ordered function signatures to ensure required arguments precede defaults (TS-71).
# 3. STATUS: API is fully synchronized with the streaming service.

from fastapi import APIRouter, Depends, status, HTTPException
from fastapi.responses import StreamingResponse
from typing import Annotated
from pymongo.database import Database
import logging

from ...models.user import UserInDB
from ...models.drafting import DraftRequest
from .dependencies import get_current_active_user, get_db
from ...services import drafting_service

router = APIRouter(tags=["Drafting V2"])
logger = logging.getLogger(__name__)

@router.post("/stream")
async def stream_legal_draft(
    request_data: DraftRequest,
    current_user: Annotated[UserInDB, Depends(get_current_active_user)],
    db: Database = Depends(get_db)
):
    """
    PHOENIX: Direct Streaming Endpoint. 
    Uses Hydra Tactic to bypass Celery for instant UI feedback.
    """
    # PHOENIX FIX: Ensure draft_type is a string (handles Optional[str] from model)
    draft_type = request_data.document_type or "generic"
    
    return StreamingResponse(
        drafting_service.stream_draft_generator(
            db=db,
            user_id=str(current_user.id),
            case_id=request_data.case_id,
            draft_type=draft_type,
            user_prompt=request_data.prompt
        ),
        media_type="text/plain"
    )

@router.post("/jobs", status_code=status.HTTP_202_ACCEPTED)
async def create_drafting_job(
    request_data: DraftRequest,
    current_user: Annotated[UserInDB, Depends(get_current_active_user)],
):
    from ...celery_app import celery_app
    try:
        task = celery_app.send_task(
            "process_drafting_job",
            kwargs={
                "case_id": request_data.case_id,
                "user_id": str(current_user.id),
                "draft_type": request_data.document_type,
                "user_prompt": request_data.prompt,
                "use_library": request_data.use_library
            }
        )
        return {"status": "Job initiated successfully", "job_id": task.id}
    except Exception as e:
        logger.error(f"Celery dispatch failed: {e}")
        raise HTTPException(status_code=500, detail="Failed to initiate job.")

@router.get("/jobs/{job_id}/status")
async def get_job_status(
    job_id: str, 
    current_user: Annotated[UserInDB, Depends(get_current_active_user)]
):
    from ...celery_app import celery_app
    from celery.result import AsyncResult
    task_result = AsyncResult(job_id, app=celery_app)
    return {"job_id": job_id, "status": task_result.status}

@router.get("/jobs/{job_id}/result")
async def get_job_result(
    job_id: str, 
    current_user: Annotated[UserInDB, Depends(get_current_active_user)], # PHOENIX FIX: Required arg before default
    db: Database = Depends(get_db)
):
    """
    Fetches the final result generated by the Agent from MongoDB.
    """
    result_doc = db.drafting_results.find_one({"job_id": job_id})
    if not result_doc: 
        raise HTTPException(status_code=404, detail="No result found.")
    return {"job_id": job_id, "result_text": result_doc.get("result_text")}